name: CI

on:
  push:
    branches:
      - '**'
  pull_request:
    types: [opened, synchronize, reopened]

jobs:
  ci:
    runs-on: ubuntu-latest

    # PostgreSQL service container for migration verification
    # Provides clean database state for testing migration up/down cycles
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        ports:
          - 5432:5432
        # Healthcheck ensures PostgreSQL is ready before migration steps run
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Story 6.6: Secret scanning (fail-fast - first quality gate)
      # Uses gitleaks to detect hardcoded secrets, API keys, and credentials
      # Placed early in pipeline to fail fast before compute-intensive steps
      - name: Scan for secrets
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version-file: go.mod
          cache: true

      - name: Install dependencies
        run: go mod download

      # Lint step uses golangci-lint with .golangci.yml configuration
      # Includes depguard rules to enforce hexagonal architecture boundaries
      # Boundary violations (e.g., domain importing infra) will fail this step
      - name: golangci-lint
        uses: golangci/golangci-lint-action@v6
        with:
          version: v1.64.2

      # OpenAPI spec validation: ensures docs/openapi.yaml is valid OpenAPI 3.1
      # Uses Spectral via Docker for consistent linting across environments
      # Validates spec syntax and style rules defined in .spectral.yaml
      - name: Validate OpenAPI spec
        run: make openapi

      # Story 6.5: Verify generated code is up-to-date
      # Runs sqlc generate and checks for uncommitted changes
      # Fails CI if developer forgot to run 'make generate' before commit
      # Install sqlc for code generation verification
      # Version matches Makefile setup to ensure consistency
      - name: Install sqlc
        run: go install github.com/sqlc-dev/sqlc/cmd/sqlc@v1.28.0

      - name: Verify generated code is up-to-date
        run: |
          make generate
          git diff --exit-code || (echo "âŒ Generated code is stale. Run 'make generate' and commit the changes." && exit 1)

      # Test step generates coverage.out profile for all packages
      - name: Run tests
        run: make test



      # Upload coverage report as artifact for debugging and visibility
      - name: Upload coverage report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: coverage.out
          retention-days: 30

      # Coverage enforcement: domain+app packages must maintain â‰¥80% coverage
      # Uses Makefile target which implements threshold check
      - name: Check coverage threshold
        id: coverage
        run: |
          # Run coverage and capture output
          make coverage 2>&1 | tee coverage-output.txt
          
          # Extract coverage percentage for badge generation
          COVERAGE=$(go tool cover -func=coverage-domain.out | tail -1 | awk '{gsub(/%/,"",$$3); print $$3}')
          echo "coverage=$COVERAGE" >> $GITHUB_OUTPUT
          echo "Coverage: $COVERAGE%"

      # Create coverage badge (requires GIST_SECRET and GIST_ID)
      # Documentation: https://github.com/schneegans/dynamic-badges-action
      - name: Create coverage badge
        uses: schneegans/dynamic-badges-action@v1.7.0
        if: github.ref == 'refs/heads/main' && secrets.GIST_SECRET != '' && secrets.GIST_ID != ''
        continue-on-error: true
        env:
          GIST_SECRET: ${{ secrets.GIST_SECRET }}
          GIST_ID: ${{ secrets.GIST_ID }}
        with:
          auth: ${{ env.GIST_SECRET }}
          gistID: ${{ env.GIST_ID }}
          filename: coverage.json
          label: coverage
          message: ${{ steps.coverage.outputs.coverage }}%
          valColorRange: ${{ steps.coverage.outputs.coverage }}
          maxColorRange: 100
          minColorRange: 0
          namedLogo: go

      # Generate and upload HTML coverage report for visual review
      - name: Generate HTML coverage report
        if: always()
        run: make coverage-html

      - name: Upload HTML coverage report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: coverage-html-report
          path: coverage.html
          retention-days: 30

      # Show uncovered functions on failure for easy debugging
      - name: Show uncovered code sections
        if: failure()
        run: |
          echo "ðŸ“Š Uncovered code sections:"
          make coverage-detail || true

      # Story 2.3: Verify all generated code (mocks) is up-to-date
      # Runs 'go generate' and checks for uncommitted changes
      - name: Verify generated code (mocks)
        run: make gencheck

      # Build verification: ensures Go binary compiles successfully
      # Build failure will cause workflow to fail (fail-fast behavior)
      - name: Build
        run: make build BINARY_NAME=/dev/null

      # Security scan: detect known vulnerabilities in dependencies
      # govulncheck is the official Go vulnerability checker from golang.org/x
      # Known CVEs will fail the workflow to prevent insecure deployments
      - name: Install govulncheck
        run: go install golang.org/x/vuln/cmd/govulncheck@v1.1.4

      - name: Security scan
        run: govulncheck ./...

      # Docker build: conditionally build image if Dockerfile exists
      # This verifies the Dockerfile is valid but does NOT push the image
      # Step is skipped gracefully when Dockerfile doesn't exist
      - name: Build Docker image
        if: hashFiles('Dockerfile') != ''
        run: docker build . -t test:ci --no-cache

      # Install goose migration tool for database migration verification
      # Uses same installation method as local development (go install)
      - name: Install goose
        run: go install github.com/pressly/goose/v3/cmd/goose@v3.26.0

      # Migration verification: validates all migrations can be applied and rolled back
      # Uses clean PostgreSQL service container - empty database state
      # Migration up applies ALL migrations to verify forward compatibility
      - name: Run migrations up
        run: make migrate-up
        env:
          DATABASE_URL: postgres://postgres:postgres@localhost:5432/test_db?sslmode=disable

      # Rollback all migrations to version 0 to verify down migrations
      # This ensures reversibility of all database changes
      # Full up/down cycle completes without error validates migration integrity
      - name: Run migrations down
        run: make migrate-down
        env:
          DATABASE_URL: postgres://postgres:postgres@localhost:5432/test_db?sslmode=disable

  # Contract Tests Job (Story 5.1)
  # Runs Pact consumer contract tests to verify API contracts
  contract-tests:
    runs-on: ubuntu-latest
    needs: [ci]

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version-file: go.mod
          cache: true

      - name: Install dependencies
        run: go mod download

      # Install Pact FFI native library required for pact-go
      - name: Install Pact FFI
        run: |
          echo "ðŸ”§ Installing Pact FFI native library..."
          go install github.com/pact-foundation/pact-go/v2@latest
          pact-go install

      # Run consumer contract tests - these generate pact files
      - name: Run Consumer Contract Tests
        run: make test-contract-consumer

      # Setup for Provider Verification
      - name: Install goose
        run: go install github.com/pressly/goose/v3/cmd/goose@v3.26.0

      - name: Run migrations up
        run: make migrate-up
        env:
          DATABASE_URL: postgres://postgres:postgres@localhost:5432/test_db?sslmode=disable

      - name: Build Application
        run: make build

      - name: Start Application
        run: |
          ./api &
          echo "Waiting for application to start..."
          # Wait for health endpoint
          timeout 30 bash -c 'until curl -s http://localhost:8080/healthz; do sleep 1; done'
        env:
          DATABASE_URL: postgres://postgres:postgres@localhost:5432/test_db?sslmode=disable
          PORT: 8080

      - name: Run Provider Verification
        run: make test-contract-provider
        env:
          PROVIDER_BASE_URL: http://localhost:8080

      # Upload generated pact files as artifacts for provider verification
      - name: Upload Pact files
        uses: actions/upload-artifact@v4
        with:
          name: pact-contracts
          path: test/contract/pacts/
          retention-days: 7
        if: always()
